/**
 * Documentation Templates
 *
 * Customizable templates for generating documentation output.
 */

import type {
  Template,
  TemplateType,
  TemplateContext,
  PackageDoc,
  ArchitectureDiagram,
  BreakingChangeReport,
} from '../types';

/**
 * Default README template
 */
export const README_TEMPLATE = `# {{name}}

> {{description}}

{{#disclaimer}}
---

**Note:** This documentation is auto-generated by Agent 14: Prophet.
All content is part of the Chicago Forest Network theoretical framework.

---
{{/disclaimer}}

## Installation

\`\`\`bash
pnpm add {{name}}
\`\`\`

## Quick Start

\`\`\`typescript
import { ... } from '{{name}}';

// Your code here
\`\`\`

## API Reference

{{#exports}}
### {{name}}

{{description}}

{{#parameters}}
**Parameters:**

| Name | Type | Description |
|------|------|-------------|
{{#.}}
| \`{{name}}\` | \`{{type}}\` | {{description}} |
{{/.}}
{{/parameters}}

{{#returns}}
**Returns:** \`{{type}}\`{{#description}} - {{description}}{{/description}}
{{/returns}}

---

{{/exports}}

## Dependencies

{{#dependencies}}
- {{name}}: {{version}}
{{/dependencies}}

## License

MIT

---

*Generated: {{generatedAt}}*
`;

/**
 * API Reference template
 */
export const API_REFERENCE_TEMPLATE = `# {{name}} API Reference

**Version:** {{version}}

{{description}}

---

## Table of Contents

{{#classes}}
- [Classes](#classes)
{{/classes}}
{{#interfaces}}
- [Interfaces](#interfaces)
{{/interfaces}}
{{#functions}}
- [Functions](#functions)
{{/functions}}
{{#types}}
- [Types](#types)
{{/types}}

---

{{#classes}}
## Classes

{{#.}}
### \`{{name}}\`

{{description}}

{{#methods}}
#### \`{{name}}()\`

{{description}}

{{#parameters}}
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
{{#.}}
| \`{{name}}\` | \`{{type}}\` | {{#optional}}No{{/optional}}{{^optional}}Yes{{/optional}} | {{description}} |
{{/.}}
{{/parameters}}

{{#returns}}
**Returns:** \`{{type}}\`
{{/returns}}

{{/methods}}

{{/classes}}

{{#interfaces}}
## Interfaces

{{#.}}
### \`{{name}}\`

{{description}}

{{#properties}}
| Property | Type | Required | Description |
|----------|------|----------|-------------|
{{#.}}
| \`{{name}}\` | \`{{type}}\` | {{#optional}}No{{/optional}}{{^optional}}Yes{{/optional}} | {{description}} |
{{/.}}
{{/properties}}

{{/interfaces}}

{{#functions}}
## Functions

{{#.}}
### \`{{name}}()\`

{{description}}

{{#parameters}}
| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
{{#.}}
| \`{{name}}\` | \`{{type}}\` | {{#optional}}No{{/optional}}{{^optional}}Yes{{/optional}} | {{defaultValue}} | {{description}} |
{{/.}}
{{/parameters}}

{{#returns}}
**Returns:** \`{{type}}\`

{{description}}
{{/returns}}

{{#examples}}
**Example:**

\`\`\`typescript
{{.}}
\`\`\`
{{/examples}}

{{/functions}}

{{#types}}
## Types

{{#.}}
### \`{{name}}\`

{{description}}

{{/types}}
`;

/**
 * Changelog template
 */
export const CHANGELOG_TEMPLATE = `# Changelog

All notable changes to {{name}} will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

{{#versions}}
## [{{version}}] - {{date}}

{{#breaking}}
### Breaking Changes

{{#.}}
- {{description}}
{{/.}}
{{/breaking}}

{{#features}}
### Added

{{#.}}
- {{subject}}{{#scope}} ({{scope}}){{/scope}}
{{/.}}
{{/features}}

{{#fixes}}
### Fixed

{{#.}}
- {{subject}}{{#scope}} ({{scope}}){{/scope}}
{{/.}}
{{/fixes}}

{{#other}}
### Changed

{{#.}}
- {{subject}}{{#scope}} ({{scope}}){{/scope}}
{{/.}}
{{/other}}

{{/versions}}
`;

/**
 * Integration Guide template
 */
export const INTEGRATION_GUIDE_TEMPLATE = `# Integrating {{source}} with {{target}}

{{description}}

## Prerequisites

{{#prerequisites}}
- {{.}}
{{/prerequisites}}

## Installation

\`\`\`bash
pnpm add {{source}} {{target}}
\`\`\`

## Integration Steps

{{#steps}}
### Step {{order}}: {{title}}

{{description}}

{{#code}}
\`\`\`typescript
{{code}}
\`\`\`
{{/code}}

{{#notes}}
> **Note:** {{.}}
{{/notes}}

{{/steps}}

## Complete Example

\`\`\`typescript
{{example}}
\`\`\`

## Troubleshooting

{{#troubleshooting}}
### {{problem}}

{{solution}}

{{#relatedLinks}}
- {{.}}
{{/relatedLinks}}

{{/troubleshooting}}
`;

/**
 * Architecture diagram template
 */
export const ARCHITECTURE_TEMPLATE = `# {{title}}

{{#description}}
{{description}}
{{/description}}

\`\`\`mermaid
{{content}}
\`\`\`

## Legend

- **Solid arrows**: Direct dependencies
- **Dashed arrows**: Optional dependencies
- **Blue boxes**: Core packages
- **Green boxes**: Utility packages
- **Gray boxes**: External dependencies

---

*Generated: {{generatedAt}}*
`;

/**
 * Template registry
 */
const templates: Map<TemplateType, string> = new Map([
  ['readme', README_TEMPLATE],
  ['api-reference', API_REFERENCE_TEMPLATE],
  ['changelog', CHANGELOG_TEMPLATE],
  ['integration-guide', INTEGRATION_GUIDE_TEMPLATE],
  ['architecture', ARCHITECTURE_TEMPLATE],
]);

/**
 * Get a template by type
 */
export function getTemplate(type: TemplateType): string {
  const template = templates.get(type);
  if (!template) {
    throw new Error(`Unknown template type: ${type}`);
  }
  return template;
}

/**
 * Register a custom template
 */
export function registerTemplate(type: TemplateType, content: string): void {
  templates.set(type, content);
}

/**
 * Simple template engine (Mustache-like)
 */
export function renderTemplate(template: string, data: Record<string, unknown>): string {
  let result = template;

  // Handle sections ({{#section}}...{{/section}})
  result = result.replace(/\{\{#(\w+)\}\}([\s\S]*?)\{\{\/\1\}\}/g, (match, key, content) => {
    const value = data[key];
    if (Array.isArray(value)) {
      return value.map(item => {
        if (typeof item === 'string') {
          return content.replace(/\{\{\.\}\}/g, item);
        }
        return renderTemplate(content, item as Record<string, unknown>);
      }).join('');
    }
    if (value) {
      return renderTemplate(content, typeof value === 'object' ? value as Record<string, unknown> : data);
    }
    return '';
  });

  // Handle inverted sections ({{^section}}...{{/section}})
  result = result.replace(/\{\{\^(\w+)\}\}([\s\S]*?)\{\{\/\1\}\}/g, (match, key, content) => {
    const value = data[key];
    if (!value || (Array.isArray(value) && value.length === 0)) {
      return content;
    }
    return '';
  });

  // Handle variables ({{variable}})
  result = result.replace(/\{\{(\w+)\}\}/g, (match, key) => {
    const value = data[key];
    if (value === undefined || value === null) return '';
    if (value instanceof Date) return value.toISOString();
    return String(value);
  });

  // Handle dot notation
  result = result.replace(/\{\{\.\}\}/g, String(data));

  return result;
}

/**
 * Render a package README
 */
export function renderReadme(pkg: PackageDoc, options: { disclaimer?: boolean } = {}): string {
  const context = {
    ...pkg,
    disclaimer: options.disclaimer ?? true,
    generatedAt: new Date().toISOString(),
    exports: groupExports(pkg.exports),
  };
  return renderTemplate(README_TEMPLATE, context as unknown as Record<string, unknown>);
}

/**
 * Render API reference
 */
export function renderApiReference(pkg: PackageDoc): string {
  const grouped = groupExports(pkg.exports);
  const context = {
    ...pkg,
    ...grouped,
  };
  return renderTemplate(API_REFERENCE_TEMPLATE, context as unknown as Record<string, unknown>);
}

/**
 * Render architecture diagram
 */
export function renderArchitectureDiagram(
  diagram: ArchitectureDiagram,
  description?: string
): string {
  return renderTemplate(ARCHITECTURE_TEMPLATE, {
    ...diagram,
    description,
    generatedAt: new Date().toISOString(),
  });
}

/**
 * Group exports by type
 */
function groupExports(exports: PackageDoc['exports']): {
  classes: PackageDoc['exports'];
  interfaces: PackageDoc['exports'];
  functions: PackageDoc['exports'];
  types: PackageDoc['exports'];
  constants: PackageDoc['exports'];
} {
  return {
    classes: exports.filter(e => e.type === 'class'),
    interfaces: exports.filter(e => e.type === 'interface'),
    functions: exports.filter(e => e.type === 'function'),
    types: exports.filter(e => e.type === 'type'),
    constants: exports.filter(e => e.type === 'constant'),
  };
}

/**
 * Load custom templates from a directory
 */
export async function loadTemplatesFromDir(dir: string): Promise<void> {
  // Implementation would read .md files from the directory
  // and register them as custom templates
  // This is a placeholder for the template loading logic
  console.log(`Loading templates from: ${dir}`);
}
