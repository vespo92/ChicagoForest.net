/**
 * Test and Schema Generators
 *
 * Generate integration tests and API schemas.
 */

import type { IntegrationPoint, BreakingChange } from '../index';

export interface GeneratedTest {
  name: string;
  description: string;
  code: string;
  dependencies: string[];
}

export interface APISchema {
  name: string;
  version: string;
  endpoints: {
    path: string;
    method: string;
    requestSchema?: object;
    responseSchema?: object;
  }[];
}

export function generateIntegrationTest(point: IntegrationPoint): GeneratedTest {
  const testCode = `
import { describe, it, expect } from 'vitest';
import { ${point.interface} } from '${point.targetPackage}';

describe('${point.name} Integration', () => {
  it('should have ${point.interface} interface available', () => {
    expect(${point.interface}).toBeDefined();
  });

  it('should be compatible with ${point.sourceRepo}', async () => {
    // Integration test for ${point.sourceRepo} compatibility
    // This validates that ${point.targetPackage} exports match expected interface

    const instance = new ${point.interface}();
    expect(instance).toBeDefined();
  });

  it('should maintain version ${point.version} compatibility', () => {
    // Version compatibility check
    expect(${point.interface}.VERSION || '${point.version}').toBe('${point.version}');
  });
});
`.trim();

  return {
    name: `${point.name}.integration.test.ts`,
    description: `Integration test for ${point.name} (${point.sourceRepo} -> ${point.targetPackage})`,
    code: testCode,
    dependencies: [point.targetPackage, 'vitest'],
  };
}

export function generateMigrationGuide(changes: BreakingChange[]): string {
  if (changes.length === 0) {
    return '# Migration Guide\n\nNo breaking changes detected. No migration required.';
  }

  const lines: string[] = [
    '# Migration Guide',
    '',
    `This guide covers ${changes.length} breaking change(s) that require attention.`,
    '',
  ];

  // Group by impact
  const byImpact = {
    high: changes.filter(c => c.impact === 'high'),
    medium: changes.filter(c => c.impact === 'medium'),
    low: changes.filter(c => c.impact === 'low'),
  };

  if (byImpact.high.length > 0) {
    lines.push('## High Impact Changes');
    lines.push('');
    for (const change of byImpact.high) {
      lines.push(`### ${change.type.toUpperCase()}: ${change.location}`);
      lines.push('');
      lines.push(change.description);
      if (change.migration) {
        lines.push('');
        lines.push(`**Migration:** ${change.migration}`);
      }
      lines.push('');
    }
  }

  if (byImpact.medium.length > 0) {
    lines.push('## Medium Impact Changes');
    lines.push('');
    for (const change of byImpact.medium) {
      lines.push(`- **${change.type}** at \`${change.location}\`: ${change.description}`);
    }
    lines.push('');
  }

  if (byImpact.low.length > 0) {
    lines.push('## Low Impact Changes');
    lines.push('');
    for (const change of byImpact.low) {
      lines.push(`- ${change.description}`);
    }
    lines.push('');
  }

  return lines.join('\n');
}

export function generateHealthDashboard(
  repos: { name: string; status: string; issues: string[] }[]
): string {
  const lines: string[] = [
    '# Ecosystem Health Dashboard',
    '',
    `**Last Updated:** ${new Date().toISOString()}`,
    '',
    '## Repository Status',
    '',
    '| Repository | Status | Issues |',
    '|------------|--------|--------|',
  ];

  for (const repo of repos) {
    const statusEmoji = repo.status === 'healthy' ? 'ðŸŸ¢' :
                        repo.status === 'warning' ? 'ðŸŸ¡' : 'ðŸ”´';
    lines.push(`| ${repo.name} | ${statusEmoji} ${repo.status} | ${repo.issues.length} |`);
  }

  lines.push('');

  const hasIssues = repos.some(r => r.issues.length > 0);
  if (hasIssues) {
    lines.push('## Issues');
    lines.push('');
    for (const repo of repos) {
      if (repo.issues.length > 0) {
        lines.push(`### ${repo.name}`);
        for (const issue of repo.issues) {
          lines.push(`- ${issue}`);
        }
        lines.push('');
      }
    }
  }

  lines.push('---');
  lines.push('*Generated by Chicago Forest Ecosystem Validator (Agent 20: Validator)*');

  return lines.join('\n');
}

export function generateAPIContract(schema: APISchema): string {
  return JSON.stringify({
    openapi: '3.0.0',
    info: {
      title: schema.name,
      version: schema.version,
    },
    paths: Object.fromEntries(
      schema.endpoints.map(ep => [
        ep.path,
        {
          [ep.method.toLowerCase()]: {
            requestBody: ep.requestSchema ? {
              content: { 'application/json': { schema: ep.requestSchema } },
            } : undefined,
            responses: {
              '200': ep.responseSchema ? {
                content: { 'application/json': { schema: ep.responseSchema } },
              } : { description: 'Success' },
            },
          },
        },
      ])
    ),
  }, null, 2);
}
