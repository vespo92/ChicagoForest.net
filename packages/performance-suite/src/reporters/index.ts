/**
 * Performance Reporters
 *
 * Generate reports from benchmark and profile data.
 */

import type { BenchmarkResult, ScalabilityResult, RegressionResult } from '../index';
import type { ProfileSummary } from '../profilers';

export function generateBenchmarkReport(results: BenchmarkResult[]): string {
  const lines: string[] = [
    '# Benchmark Report',
    '',
    `**Generated:** ${new Date().toISOString()}`,
    '',
    '## Results',
    '',
    '| Benchmark | Iterations | Avg (ms) | Min (ms) | Max (ms) | Std Dev | Ops/s |',
    '|-----------|------------|----------|----------|----------|---------|-------|',
  ];

  for (const result of results) {
    lines.push(
      `| ${result.name} | ${result.iterations} | ${result.averageTimeMs.toFixed(3)} | ${result.minTimeMs.toFixed(3)} | ${result.maxTimeMs.toFixed(3)} | ${result.standardDeviation.toFixed(3)} | ${result.opsPerSecond.toFixed(0)} |`
    );
  }

  lines.push('');
  lines.push('---');
  lines.push('*Generated by Chicago Forest Performance Suite (Agent 19: Benchmarker)*');

  return lines.join('\n');
}

export function generateScalabilityReport(results: ScalabilityResult[]): string {
  const lines: string[] = [
    '# Scalability Report',
    '',
    `**Generated:** ${new Date().toISOString()}`,
    '',
    '## Results',
    '',
    '| Nodes | Throughput (ops/s) | Latency (ms) | Efficiency |',
    '|-------|-------------------|--------------|------------|',
  ];

  for (const result of results) {
    lines.push(
      `| ${result.nodeCount} | ${result.throughput.toFixed(0)} | ${result.latency.toFixed(2)} | ${result.efficiency.toFixed(3)} |`
    );
  }

  // Calculate scaling efficiency
  if (results.length >= 2) {
    const first = results[0];
    const last = results[results.length - 1];
    const scalingFactor = last.nodeCount / first.nodeCount;
    const throughputFactor = last.throughput / first.throughput;
    const scalingEfficiency = (throughputFactor / scalingFactor) * 100;

    lines.push('');
    lines.push('## Scaling Analysis');
    lines.push('');
    lines.push(`- **Node scale:** ${first.nodeCount} â†’ ${last.nodeCount} (${scalingFactor.toFixed(1)}x)`);
    lines.push(`- **Throughput scale:** ${first.throughput.toFixed(0)} â†’ ${last.throughput.toFixed(0)} (${throughputFactor.toFixed(1)}x)`);
    lines.push(`- **Scaling efficiency:** ${scalingEfficiency.toFixed(1)}%`);

    if (scalingEfficiency >= 90) {
      lines.push('- **Assessment:** ðŸŸ¢ Excellent linear scaling');
    } else if (scalingEfficiency >= 70) {
      lines.push('- **Assessment:** ðŸŸ¡ Good scaling with some overhead');
    } else if (scalingEfficiency >= 50) {
      lines.push('- **Assessment:** ðŸŸ  Moderate scaling, review bottlenecks');
    } else {
      lines.push('- **Assessment:** ðŸ”´ Poor scaling, significant bottlenecks');
    }
  }

  return lines.join('\n');
}

export function generateRegressionReport(results: RegressionResult[]): string {
  const regressions = results.filter(r => r.isRegression);
  const improvements = results.filter(r => r.changePercent < -0.05);

  const lines: string[] = [
    '# Performance Regression Report',
    '',
    `**Generated:** ${new Date().toISOString()}`,
    '',
    `**Status:** ${regressions.length > 0 ? 'âŒ REGRESSIONS DETECTED' : 'âœ… NO REGRESSIONS'}`,
    '',
  ];

  if (regressions.length > 0) {
    lines.push('## Regressions');
    lines.push('');
    for (const r of regressions) {
      lines.push(`### ${r.benchmark}`);
      lines.push(`- Baseline: ${r.baseline.toFixed(3)}ms`);
      lines.push(`- Current: ${r.current.toFixed(3)}ms`);
      lines.push(`- Change: **+${(r.changePercent * 100).toFixed(1)}%** (threshold: ${(r.threshold * 100).toFixed(0)}%)`);
      lines.push('');
    }
  }

  if (improvements.length > 0) {
    lines.push('## Improvements');
    lines.push('');
    for (const r of improvements) {
      lines.push(`- **${r.benchmark}:** ${(r.changePercent * 100).toFixed(1)}% faster`);
    }
    lines.push('');
  }

  lines.push('## Summary');
  lines.push('');
  lines.push(`| Status | Count |`);
  lines.push(`|--------|-------|`);
  lines.push(`| Regressions | ${regressions.length} |`);
  lines.push(`| Improvements | ${improvements.length} |`);
  lines.push(`| Stable | ${results.length - regressions.length - improvements.length} |`);

  return lines.join('\n');
}

export function generateProfileReport(summary: ProfileSummary, sessionId: string): string {
  return [
    '# Profile Report',
    '',
    `**Session:** ${sessionId}`,
    `**Duration:** ${(summary.duration / 1000).toFixed(2)}s`,
    '',
    '## CPU Usage',
    `- Average: ${summary.avgCpuPercent.toFixed(1)}%`,
    `- Maximum: ${summary.maxCpuPercent.toFixed(1)}%`,
    '',
    '## Memory Usage',
    `- Average: ${summary.avgMemoryMb.toFixed(1)} MB`,
    `- Maximum: ${summary.maxMemoryMb.toFixed(1)} MB`,
    '',
    '## Event Loop',
    `- Average Latency: ${summary.avgEventLoopLatency.toFixed(2)}ms`,
    `- Maximum Latency: ${summary.maxEventLoopLatency.toFixed(2)}ms`,
  ].join('\n');
}
